# GitHub Actions CI/CD Pipeline for Python Application
#
# This workflow demonstrates a complete CI/CD pipeline for a Python web application.
# It includes building, testing, security scanning, Docker image creation, and deployment.
#
# Workflow Triggers:
# - Runs on every push to main and develop branches
# - Runs on pull requests targeting main
# - Can be manually triggered via workflow_dispatch
# - Runs nightly for scheduled tasks (dependency updates, security scans)

name: Python CI/CD Pipeline

# =============================================================================
# TRIGGERS - Define when this workflow should run
# =============================================================================
on:
  # Trigger on push events to specific branches
  push:
    branches:
      - main        # Production branch
      - develop     # Development branch
    # Optionally ignore certain paths to avoid unnecessary builds
    paths-ignore:
      - '**.md'     # Don't run on README changes
      - 'docs/**'   # Don't run on documentation changes

  # Trigger on pull requests targeting main
  pull_request:
    branches:
      - main
    # Only run when specific file types change
    paths:
      - 'src/**'
      - 'tests/**'
      - 'requirements*.txt'
      - '.github/workflows/**'

  # Allow manual triggering from GitHub UI
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

  # Scheduled runs (cron syntax: minute hour day month weekday)
  schedule:
    - cron: '0 2 * * 1'  # Every Monday at 2 AM UTC

# =============================================================================
# ENVIRONMENT VARIABLES - Available to all jobs
# =============================================================================
env:
  PYTHON_VERSION: '3.11'              # Python version to use
  DOCKER_IMAGE_NAME: 'myapp'          # Docker image name
  DOCKER_REGISTRY: 'ghcr.io'          # GitHub Container Registry
  MIN_COVERAGE: 80                    # Minimum test coverage percentage

# =============================================================================
# JOBS - Independent units of work that can run in parallel
# =============================================================================
jobs:

  # ---------------------------------------------------------------------------
  # JOB: Code Quality Checks
  # Runs linting and static analysis to ensure code quality
  # ---------------------------------------------------------------------------
  code-quality:
    name: Code Quality & Linting
    runs-on: ubuntu-latest  # Use latest Ubuntu runner

    steps:
      # Step 1: Check out the repository code
      # This makes the repository's code available to subsequent steps
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for accurate blame info

      # Step 2: Set up Python environment
      # Uses the setup-python action to install and configure Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          # Cache pip dependencies to speed up subsequent runs
          # Cache key based on requirements.txt hash - invalidates when dependencies change
          cache: 'pip'
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt

      # Step 3: Install linting and formatting tools
      - name: Install development dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black mypy pylint isort bandit

      # Step 4: Check code formatting with Black
      # Black is an opinionated code formatter
      # --check flag means it won't modify files, just report differences
      - name: Check code formatting with Black
        run: |
          black --check --diff src/ tests/
        continue-on-error: false  # Fail the workflow if formatting issues found

      # Step 5: Check import sorting with isort
      # isort automatically sorts and organizes imports
      - name: Check import sorting with isort
        run: |
          isort --check-only --diff src/ tests/

      # Step 6: Lint with Flake8
      # Flake8 checks for PEP 8 style guide compliance and common errors
      - name: Lint with Flake8
        run: |
          # Stop the build if there are Python syntax errors or undefined names
          flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
          # Exit-zero treats all errors as warnings
          # Default max line length is 88 (Black's default)
          flake8 src/ --count --exit-zero --max-complexity=10 --max-line-length=88 --statistics

      # Step 7: Type checking with mypy
      # mypy performs static type checking using Python type hints
      - name: Type checking with mypy
        run: |
          mypy src/ --ignore-missing-imports --strict
        continue-on-error: true  # Don't fail build on type errors (warning only)

      # Step 8: Security check with Bandit
      # Bandit finds common security issues in Python code
      - name: Security linting with Bandit
        run: |
          bandit -r src/ -f json -o bandit-report.json
          bandit -r src/ -ll  # Show only medium and high severity issues

      # Step 9: Upload Bandit report as artifact
      # Artifacts are files persisted after the workflow completes
      - name: Upload Bandit security report
        if: always()  # Upload even if previous steps failed
        uses: actions/upload-artifact@v4
        with:
          name: bandit-security-report
          path: bandit-report.json
          retention-days: 30  # Keep artifact for 30 days

  # ---------------------------------------------------------------------------
  # JOB: Unit and Integration Tests
  # Runs the test suite with coverage reporting
  # Uses a matrix strategy to test on multiple Python versions
  # ---------------------------------------------------------------------------
  test:
    name: Test Suite (Python ${{ matrix.python-version }})
    runs-on: ubuntu-latest

    # Matrix strategy allows running the same job with different configurations
    # This will create separate jobs for each Python version
    strategy:
      # fail-fast: false means all matrix jobs continue even if one fails
      fail-fast: false
      matrix:
        python-version: ['3.9', '3.10', '3.11']  # Test on multiple Python versions

    # Service containers run alongside the job
    # Useful for databases, caches, message queues, etc.
    services:
      # PostgreSQL database service
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        # Health check ensures service is ready before tests run
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432  # Expose PostgreSQL port

      # Redis cache service
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379  # Expose Redis port

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      # Install both production and development dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      # Run pytest with various options
      - name: Run tests with coverage
        run: |
          pytest tests/ \
            --verbose \
            --cov=src \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --cov-fail-under=${{ env.MIN_COVERAGE }} \
            --junitxml=test-results.xml
        env:
          # Environment variables available to tests
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379
          ENVIRONMENT: test

      # Upload coverage report to Codecov
      # Codecov provides coverage tracking and visualization
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml
          flags: python-${{ matrix.python-version }}
          name: coverage-${{ matrix.python-version }}
          fail_ci_if_error: true  # Fail if upload fails

      # Upload test results for GitHub's test reporting
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.python-version }}
          path: test-results.xml

      # Upload HTML coverage report
      - name: Upload coverage HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ matrix.python-version }}
          path: htmlcov/

  # ---------------------------------------------------------------------------
  # JOB: Dependency Security Scanning
  # Checks for known vulnerabilities in dependencies
  # ---------------------------------------------------------------------------
  dependency-security:
    name: Dependency Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Safety checks Python dependencies for known security vulnerabilities
      - name: Check dependencies with Safety
        run: |
          pip install safety
          # Check for known vulnerabilities in requirements.txt
          safety check --file requirements.txt --json > safety-report.json
          safety check --file requirements.txt
        continue-on-error: true  # Don't fail build, but report issues

      # pip-audit is another tool for checking vulnerabilities
      - name: Audit dependencies with pip-audit
        run: |
          pip install pip-audit
          pip-audit --requirement requirements.txt --format json > pip-audit-report.json
          pip-audit --requirement requirements.txt

      # Upload security reports
      - name: Upload security scan results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-security-reports
          path: |
            safety-report.json
            pip-audit-report.json

  # ---------------------------------------------------------------------------
  # JOB: Build Docker Image
  # Creates a Docker image for the application
  # Only runs after tests pass
  # ---------------------------------------------------------------------------
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    # This job depends on successful completion of these jobs
    needs: [code-quality, test]
    # Only build on main/develop branches or PRs to main
    if: github.event_name != 'schedule'

    # Permissions needed to push to GitHub Container Registry
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Set up Docker Buildx for advanced build features
      # Buildx enables multi-platform builds and better caching
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Extract metadata for Docker tags and labels
      # This automatically generates appropriate tags based on git ref
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}
          # Tagging strategy:
          # - main branch -> latest, sha-abc123
          # - develop branch -> develop, sha-abc123
          # - PR -> pr-123
          # - version tags -> v1.2.3, v1.2, v1, latest
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix={{branch}}-

      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          # GITHUB_TOKEN is automatically provided by GitHub Actions
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build and push Docker image
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          # Push to registry only on main/develop branches, not on PRs
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Use BuildKit cache for faster builds
          cache-from: type=gha  # GitHub Actions cache
          cache-to: type=gha,mode=max
          # Build arguments (available in Dockerfile as ARG)
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}

  # ---------------------------------------------------------------------------
  # JOB: Scan Docker Image for Vulnerabilities
  # Uses Trivy to scan the built image
  # ---------------------------------------------------------------------------
  scan-docker:
    name: Scan Docker Image
    runs-on: ubuntu-latest
    needs: [build-docker]
    if: github.event_name != 'schedule' && github.event_name != 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Login to pull the image we just built
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Run Trivy vulnerability scanner
      # Trivy detects vulnerabilities in OS packages and application dependencies
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.ref_name }}-${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      # Upload results to GitHub Security tab
      # SARIF format is used by GitHub's code scanning
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      # Also run Trivy with table output for easier reading in logs
      - name: Run Trivy scanner (table output)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.ref_name }}-${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
          # Fail the build if critical vulnerabilities found
          exit-code: '1'

  # ---------------------------------------------------------------------------
  # JOB: Deploy to Staging
  # Deploys the application to staging environment
  # ---------------------------------------------------------------------------
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-docker, scan-docker]
    # Only deploy from develop branch
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'

    # Use GitHub environments for deployment protection rules
    environment:
      name: staging
      url: https://staging.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Example: Deploy to Kubernetes cluster
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # Configure kubectl to connect to cluster
      # In real scenario, use cluster credentials from secrets
      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig.yaml
          export KUBECONFIG=kubeconfig.yaml

      # Update Kubernetes deployment with new image
      - name: Deploy to Staging
        run: |
          # Update deployment with new image
          kubectl set image deployment/myapp \
            myapp=${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}:develop-${{ github.sha }} \
            -n staging

          # Wait for rollout to complete
          kubectl rollout status deployment/myapp -n staging --timeout=5m

      # Run smoke tests to verify deployment
      - name: Run smoke tests
        run: |
          sleep 30  # Wait for service to stabilize
          curl -f https://staging.example.com/health || exit 1
          curl -f https://staging.example.com/api/status || exit 1

      # Notify team on Slack (example)
      - name: Notify deployment
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Staging deployment ${{ job.status }}: ${{ github.repository }}@${{ github.sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Staging deployment *${{ job.status }}*\nRepository: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nCommit: ${{ github.sha }}\nURL: https://staging.example.com"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ---------------------------------------------------------------------------
  # JOB: Deploy to Production
  # Deploys to production with manual approval
  # ---------------------------------------------------------------------------
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-docker, scan-docker]
    # Only deploy from main branch
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    # Production environment with required reviewers
    environment:
      name: production
      url: https://example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig.yaml
          export KUBECONFIG=kubeconfig.yaml

      # Production deployment with additional safety measures
      - name: Deploy to Production
        run: |
          # Tag image as production
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}:main-${{ github.sha }}
          docker tag ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}:main-${{ github.sha }} \
                     ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}:latest

          # Deploy with zero-downtime rolling update
          kubectl set image deployment/myapp \
            myapp=${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE_NAME }}:main-${{ github.sha }} \
            -n production

          # Wait and monitor rollout
          kubectl rollout status deployment/myapp -n production --timeout=10m

      # Health check with automatic rollback on failure
      - name: Verify deployment health
        run: |
          # Wait for service to stabilize
          sleep 60

          # Run health checks
          for i in {1..5}; do
            if curl -f https://example.com/health; then
              echo "Health check passed"
              exit 0
            fi
            echo "Health check failed, attempt $i/5"
            sleep 10
          done

          # Rollback if health checks fail
          echo "Health checks failed, rolling back"
          kubectl rollout undo deployment/myapp -n production
          exit 1

      - name: Notify production deployment
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "ðŸš€ Production deployment ${{ job.status }}: ${{ github.repository }}@${{ github.sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸš€ Production deployment *${{ job.status }}*\nRepository: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nCommit: ${{ github.sha }}\nDeployed by: ${{ github.actor }}\nURL: https://example.com"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
